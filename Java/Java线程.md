## 简介

进程时操作系统分配资源(CPU,内存,IO,磁盘)的单位。

线程是CPU分配时间的单位。

## 线程状态

### 创建
在生成线程对象，并且还没有调用该对象的start方法时，此时线程状态为NEW</li>
### 就绪
调用了线程对象的start方法，并且该线程没有被block，但是此时线程调度程序还没有吧该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或睡眠中回来之后，也处于就绪状态。此时线程状态为RUNABLE。
### 运行
线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入运行状态，开始执行run方法内的代码。此时线程状态为RUNABLE。</li>
#### 阻塞
线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep，suspend，wait,join等方法都可以导致线程阻塞。此时线程的状态有三种:

* BLOCKED：仅仅会发生在线程期望进入同步代码块或同步方法，并且尚未获得锁的情况下，这有两种可能，一种是线程直接从运行状态抢锁进入同步代码；另一种是线程在执行了wait方法后，被notify/notifyAll(或者wait(long)时间到期)唤醒，然后希望重新抢锁的情况下，可以直接进入blocked状态。处于BLOCKED状态的线程，只有在获得了锁之后，才会脱离阻塞状态。
* TIMED_WAITING：线程执行了wait(long)，sleep(long),wait(long)，会触发线程进入TIMED_WAITING状态，在这种状态下与普通的WAITING状态相似，但是当设定时间到了，就会脱离阻塞状态。
* WAITING：当调用了join()或wait()方法，就会进入WAITING状态，如果是因为调用join()方法进入WAITING状态，则当join的目标线程执行完毕，该线程就会进入到RUNNABLE状态，如果是因为调用wait()进入的WAITING，则需要等待锁对象执行了notify()或notifyAll之后才能脱离阻塞。

**注意**：无论上面3中哪种阻塞状态，都只能是从运行RUNNING状态转换得来。

* 死亡：一个线程的run方法执行结束或抛出异常或者调用stop方法并完成对线程的中止之后，该线程死亡。此时线程状态为TERMINATED