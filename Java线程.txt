Java线程
进程时操作系统分配资源(CPU,内存,IO,磁盘)的单位
线程是CPU分配时间的单位。

线程状态：创建、就绪、运行、阻塞、死亡
	1.创建，在生成线程对象，并且还没有调用该对象的start方法时，此时线程状态为NEW
	2.就绪，调用了线程对象的start方法，并且该线程没有被block，但是此时线程调度程序还没有吧该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或睡眠中回来之后，也处于就绪状态。此时线程状态为RUNABLE。
	3.运行，线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入运行状态，开始执行run方法内的代码。此时线程状态为RUNABLE。
	4.阻塞，线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep，suspend，wait,join等方法都可以导致线程阻塞。此时线程的状态有三种
		BLOCKED：仅仅会发生在线程期望进入同步代码块或同步方法，并且尚未获得锁的情况下，这有两种可能，一种是线程直接从运行状态抢锁进入同步代码；另一种是线程在执行了wait方法后，被notify/notifyAll(或者wait(long)时间到期)唤醒，然后希望重新抢锁的情况下，可以直接进入blocked状态。处于BLOCKED状态的线程，只有在获得了锁之后，才会脱离阻塞状态。
		TIMED_WAITING：线程执行了wait(long)，sleep(long),wait(long)，会触发线程进入TIMED_WAITING状态，在这种状态下与普通的WAITING状态相似，但是当设定时间到了，就会脱离阻塞状态。
		WAITING：当调用了join()或wait()方法，就会进入WAITING状态，如果是因为调用join()方法进入WAITING状态，则当join的目标线程执行完毕，该线程就会进入到RUNNABLE状态，如果是因为调用wait()进入的WAITING，则需要等待锁对象执行了notify()或notifyAll之后才能脱离阻塞。
		注意：无论上面3中哪种阻塞状态，都只能是从运行RUNNING状态转换得来。
	5.死亡：一个线程的run方法执行结束或抛出异常或者调用stop方法并完成对线程的中止之后，该线程死亡。此时线程状态为TERMINATED

虚拟机栈中存储的是局部变量表、动态链接、方法出口
局部变量表中存储的主要是下面的数据：
	1.基本数据类型(boolean、byte、char、short、int、float),每个变量占有一个内存单元。这些变量在堆内存中也有一份，在每个线程的局部变量表中，存储的是堆内存中对这份数据的拷贝。
	2.基本数据类型(long、double)，与其他基本数据类型一样，但是数据占有两个内存单元。
	3.String类型，String类型是一个对象，在局部变量表中永远只是一个引用。String与基本数据类型一致，是覆盖修改的，String是不可变字符序列，String一旦创建，就不能对其Value进行修改，如果需要修改，只能先创建一个新的对象，并将引用指向新的对象。
	4.普通对象引用，线程中存储的没有对象，只有对象引用
	5.返回地址，指向了一条字节码指令的地址，不属于变量的一部分

java内存模型
