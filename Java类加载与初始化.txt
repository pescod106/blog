Java类加载与初始化

1.类加载器
每个类编译后产生一个Class对象，存储为.class文件，JVM使用类加载器ClassLoader来加载类的字节码文件(.class)，一般的，只会用到一个原生的类加载器，它只加载Java API等可信类，通常只在本地磁盘中加载。如果需要从远程网络或数据库中下载.class文件。需要挂载额外的类加载器。

一般来说，类加载器是按照树形的层次结构组织的。每一个加载器都有一个父类加载器。另外每个类加载器都支持代理模式，既可以自己完成Java类的加载工作，也可以起代理给其他的类加载器。

类加载器的加载顺序有两种，父类有限策略、自己有限策略。父类有限策略是一般的情况(JDK)，在这种策略下，类在加载某个Java类之前，会尝试代理给其父类加载器，只有当父类加载器找不到时，才尝试自己加载。自己优先策略正好相反，它会尝试自己去加载，找不到的时候才要父类加载器去加载，这种在Web容器中比较常见(Tomcat)。

2.动态加载
类都是第一次被用到时，动态加载到JVM的
 1.Java程序在运行时不一定被完全加载，只有发现该类还没有被加载时，才会去本地或远程查找类的.class文件，并验证和加载。
 2.当程序创建了第一个对类的静态成员的引用时，才会加载该类(静态变量、静态方法、静态的构造方法)。这个特性叫做：动态加载
需要区分加载和初始化的区别，加载了一个类的.class文件，不意味着该Class对象被初始化，类的初始化分为三个步骤：
 1.加载：由类加载器执行，查找字节码，并创建一个Class对象
 2.链接：验证字节码，为静态域分配存储空间(只是分配，并不初始化该存储空间)，解析该类创建所需要的对其他类的引用。
 3.初始化：首先执行静态初始化快static{},初始化静态变量，执行静态方法(如构造方法)。

3.链接
就是将已经加载的Java二进制代码组合到JVM运行状态中去，分为三个步骤
 	1.验证：保证二进制字节码在结构上的正确性
 	2.准备：创建静态域、分配空间、给这些
 	3.解析：对类中的接口、类、方法、变量的符号引用进行解析并定位，解析成直接引用，并保证这些类被正常找到。解析的过程可能导致其他的类被加载。有些解析策略在解析时递归的把所有引用解析，这是early resolution。要求所有引用必须存在；还有一种策略是late resolution，即在类中只是被引用了,还没有被真正用到时，并不进行解析，只有当真正用到的时候，才去加载和解析这个类。
4.初始化
static{}是在第一次初始化时执行的，且执行一次。

根据Java虚拟机规范，所有Java虚拟机实现必须在每个类或接口被Java程序首次主动使用时才初始化。
主动使用有以下6种：
 1.创建类的实例
 2.访问类或接口中的静态变量，或者对该静态变量赋值(如果访问静态编译时常量(即编译时可以确定值的常量)不会导致类的初始化)
 3.调用类的静态方法
 4.反射(Class.forName(xxx.xxx.xxx))
 5.初始化一个类的子类(相当于对父类的主动使用)，不过直接通过子类引用父类元素，不会引起子类的初始化
 6.Java虚拟机被标明为启动类的类(包含main方法的)

用类字面常量.class和Class.foeName都可以创建对类的引用，但是不同点在于.class创建Class对象的引用时(Class c = Test.class)，不会自动初始化该Class对象(static字句不会执行)
编译时常量，常量被static、final限定，不需要初始化就可以读取
当访问一个Java类或接口的静态域时，只有真正声明这个域的类或者接口才会被初始化
